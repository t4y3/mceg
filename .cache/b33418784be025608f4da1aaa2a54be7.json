{"dependencies":[],"generated":{"js":"\"use strict\";\n\n/**\n * Pixel Clustering module\n * http://rest-term.com\n */(function () {\n  var PixelCluster; // top-level namaspace\n  var _root = this; // reference to 'window' or 'global'\n\n  if (typeof exports !== 'undefined') {\n    PixelCluster = exports; // for CommonJS\n  } else {\n    PixelCluster = _root.PixelCluster = {};\n  }\n\n  var ctx = null,\n      image = null,\n      imgData = null,\n      worker = new Worker('./kmeans.js');\n\n  var core = {\n    // load: function(fileName, onComplete, onError) {\n    load: function load(target, onComplete, onError) {\n      ctx = document.createElement('canvas').getContext('2d');\n      // image = new Image();\n      imgData = null;\n      // image.addEventListener('load', function(e) {\n      var img = target;\n      ctx.canvas.width = img.width;\n      ctx.canvas.height = img.height;\n      ctx.drawImage(img, 0, 0);\n      imgData = ctx.getImageData(0, 0, img.width, img.height);\n      if (typeof onComplete === 'function') {\n        onComplete(imgData, new Date());\n      }\n      // }, false);\n      // image.addEventListener('error', function() {\n      //     if (typeof onError === 'function') {\n      //         onError();\n      //     }\n      // }, false);\n      // image.src = fileName;\n    },\n    perform: function perform(division, ncluster, method, onComplete, onError) {\n      var features = core.extractFeatures(division);\n      if (typeof onComplete === 'undefined') {\n        var codebook = core.kmeans(features, ncluster, method);\n        var result = core.vq(features, codebook[\"centroids\"], codebook[\"code\"]);\n        return result;\n      } else {\n        var message = {\n          \"samples\": features,\n          \"ncluster\": ncluster,\n          \"method\": method\n        };\n        worker.postMessage(message);\n        worker.addEventListener('message', function (e) {\n          e.target.removeEventListener('message', arguments.callee);\n          if (typeof onComplete === 'function') {\n            onComplete(e.data);\n          }\n        }, false);\n        worker.addEventListener('error', function (e) {\n          e.target.removeEventListener('error', arguments.callee);\n          if (typeof onError === 'function') {\n            onError();\n          }\n        }, false);\n        return true;\n      }\n    },\n    /* extracts feature vectors */\n    extractFeatures: function extractFeatures(division) {\n      var w = imgData.width,\n          h = imgData.height,\n          data = imgData.data,\n          len = w * h * 4,\n          features = [],\n          bins = [0, 0, 0],\n          step,\n          kstep,\n          dx,\n          dy,\n          inv,\n          i,\n          j;\n\n      if (w % division != 0 || h % division != 0) {\n        throw Error('invalid parameter: division');\n      }\n      dx = w / division;\n      dy = h / division;\n      inv = 1 / (dx * dy);\n      // means of each color, each segment\n      for (var y = 0; y < division; y++) {\n        step = y * dy * w << 2;\n        for (var x = 0; x < division; x++) {\n          i = step + (x * dx << 2);\n          bins = [0, 0, 0];\n          for (var ky = 0; ky < dy; ky++) {\n            kstep = i + (ky * w << 2);\n            for (var kx = 0; kx < dx; kx++) {\n              j = kstep + (kx << 2);\n              bins[0] += data[j]; // R\n              bins[1] += data[j + 1]; // G\n              bins[2] += data[j + 2]; // B\n            }\n          }\n          features.push([bins[0] * inv, bins[1] * inv, bins[2] * inv]);\n        }\n      }\n      return features;\n    },\n    /* performs k-means on a set of observation vectors forming k clusters */\n    kmeans: function kmeans(samples, ncluster, method) {\n      var centroids = [],\n          previous = [],\n          clusters = [],\n          code = [],\n          len = samples.length,\n          eps = 1.0e-8,\n          maxIter = 1000,\n          iter = 0,\n          distance = function distance(a, b) {\n        var dr = a[0] - b[0],\n            dg = a[1] - b[1],\n            db = a[2] - b[2];\n        return dr * dr + dg * dg + db * db;\n      },\n          nearest = function nearest(sample, centroids) {\n        var minIndex = 0,\n            minDistance = Number.MAX_VALUE,\n            clusterCount = centroids.length;\n        for (var k = 0; k < clusterCount; k++) {\n          var d = distance(centroids[k], sample);\n          if (minDistance > d) {\n            minDistance = d;\n            minIndex = k;\n          }\n        }\n        return [minIndex, minDistance];\n      },\n          initialize = function initialize(samples, ncluster, method, centroids, clusters) {\n        var len = samples.length;\n        if (method === 'kmeans_pp') {\n          // kmeans++\n          var d = [],\n              sumDistance = 0.0,\n              label,\n              k,\n              i,\n              r = Math.floor(Math.random() * len);\n          centroids[0] = [];\n          centroids[0][0] = samples[r][0];\n          centroids[0][1] = samples[r][1];\n          centroids[0][2] = samples[r][2];\n          previous[0] = [0.0, 0.0, 0.0];\n          clusters[0] = [];\n          for (k = 1; k < ncluster; k++) {\n            sumDistance = 0.0;\n            for (i = 0; i < len; i++) {\n              d[i] = nearest(samples[i], centroids)[1];\n              sumDistance += d[i];\n            }\n            sumDistance *= Math.random();\n            for (i = 0; i < len; i++) {\n              sumDistance -= d[i];\n              if (sumDistance > 0) continue;\n              centroids[k] = [];\n              centroids[k][0] = samples[i][0];\n              centroids[k][1] = samples[i][1];\n              centroids[k][2] = samples[i][2];\n              break;\n            }\n            previous[k] = [0.0, 0.0, 0.0];\n            clusters[k] = [];\n          }\n          for (i = 0; i < len; i++) {\n            label = nearest(samples[i], centroids);\n            clusters[label[0]].push(samples[i]);\n          }\n        } else {\n          // random\n          for (k = 0; k < ncluster; k++) {\n            centroids[k] = [Math.random() * 255, Math.random() * 255, Math.random() * 255];\n            previous[k] = [0.0, 0.0, 0.0];\n            clusters[k] = [];\n          }\n          for (i = 0; i < len; i++) {\n            label = Math.floor(Math.random() * k);\n            clusters[label].push(samples[i]);\n          }\n        }\n      },\n          canTerminate = function canTerminate() {\n        var cnt = 0;\n        for (var k = 0; k < ncluster; k++) {\n          if (distance(centroids[k], previous[k]) < eps) cnt++;\n        }\n        if (cnt === ncluster) return true;else return false;\n      },\n          sumDistance = function sumDistance(centroids) {\n        var sum = 0.0,\n            len = centroids.length;\n        for (var i = 0; i < len - 1; i++) {\n          sum += distance(centroids[i], centroids[i + 1]);\n        }\n        return sum;\n      };\n      // initializes centroids and clusters\n      initialize(samples, ncluster, method, centroids, clusters);\n\n      while (!canTerminate() && iter < maxIter) {\n        iter++;\n        // calculates centroids\n        for (var k = 0; k < ncluster; k++) {\n          if (!clusters[k] || !clusters.length) continue;\n          var r = 0.0,\n              g = 0.0,\n              b = 0.0,\n              llen = clusters[k].length;\n          for (var i = 0; i < llen; i++) {\n            r += clusters[k][i][0];\n            g += clusters[k][i][1];\n            b += clusters[k][i][2];\n          }\n          previous[k][0] = centroids[k][0];\n          previous[k][1] = centroids[k][1];\n          previous[k][2] = centroids[k][2];\n          centroids[k] = [r / llen, g / llen, b / llen];\n        }\n        // updates clusters\n        clusters = [];\n        code = [];\n        for (i = 0; i < len; i++) {\n          var minDistance = Number.MAX_VALUE,\n              currentLabel = -1;\n          for (k = 0; k < ncluster; k++) {\n            var d = distance(centroids[k], samples[i]);\n            if (d < minDistance) {\n              minDistance = d;\n              currentLabel = k;\n            }\n          }\n          if (!clusters[currentLabel]) clusters[currentLabel] = [];\n          if (!code[currentLabel]) code[currentLabel] = [];\n          clusters[currentLabel].push(samples[i]);\n          code[currentLabel].push(i);\n        }\n      }\n      return {\n        \"centroids\": centroids,\n        \"code\": code\n      };\n    },\n    /* quantizing vectors by comparing them with centroids */\n    vq: function vq(samples, centroids, code) {\n      var ncluster = centroids.length,\n          len = samples.length;\n      for (var k = 0; k < ncluster; k++) {\n        var ilen = code[k].length;\n        for (var i = 0; i < ilen; i++) {\n          samples[code[k][i]] = centroids[k];\n        }\n      }\n      return samples;\n    },\n    render: function render(context, division, features) {\n      var w = imgData.width,\n          h = imgData.height,\n          data = imgData.data,\n          dstImgData = context.getImageData(0, 0, w, h),\n          dstData = dstImgData.data,\n          len = w * h * 4,\n          step,\n          kstep,\n          dx,\n          dy,\n          inv,\n          i,\n          j;\n      if (w % division != 0 || h % division != 0) {\n        throw Error('invalid parameter: division');\n      }\n      dx = w / division;\n      dy = h / division;\n      inv = 1 / (dx * dy);\n      // means of each color, each segment\n      var f = 0,\n          p = [];\n      for (var y = 0; y < division; y++) {\n        step = y * dy * w << 2;\n        for (var x = 0; x < division; x++) {\n          i = step + (x * dx << 2);\n          p = features[f++];\n          for (var ky = 0; ky < dy; ky++) {\n            kstep = i + (ky * w << 2);\n            for (var kx = 0; kx < dx; kx++) {\n              j = kstep + (kx << 2);\n              dstData[j] = p[0];\n              dstData[j + 1] = p[1];\n              dstData[j + 2] = p[2];\n              dstData[j + 3] = 255;\n            }\n          }\n        }\n      }\n      context.putImageData(dstImgData, 0, 0);\n    }\n  };\n  // public APIs\n  PixelCluster.load = core.load;\n  PixelCluster.mosaic = core.extractFeatures;\n  PixelCluster.perform = core.perform; // using web workers\n  PixelCluster.render = core.render;\n  PixelCluster.KMEANS_PP = \"kmeans_pp\";\n  PixelCluster.KMEANS_RANDOM = \"kmeans_random\";\n}).call(undefined);"},"hash":"00aba08b95c8c14c600efb902c77e88a"}