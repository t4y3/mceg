{"dependencies":[{"name":"node-kmeans"},{"name":"cropperjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _nodeKmeans = require(\"node-kmeans\");\n\nvar _nodeKmeans2 = _interopRequireDefault(_nodeKmeans);\n\nvar _cropperjs = require(\"cropperjs\");\n\nvar _cropperjs2 = _interopRequireDefault(_cropperjs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// canvasサイズ\nvar CANVAS_SIZE = 32;\n// 表示時のグリッドのサイズ\nvar GRID_SIZE = 10;\n// 表示用canvasサイズ\nvar CANVAS_DISP_SIZE = CANVAS_SIZE * GRID_SIZE;\n// 減色時の色数\nvar K_NUM = 16;\n// MGOでのカラーパレット用の除数\nvar DIVISOR = 8.21;\n\nvar Cluster = function () {\n  function Cluster() {\n    _classCallCheck(this, Cluster);\n\n    this.cropper = null;\n\n    // カラーコードのリスト\n    this.highlightList = [];\n    this.colorList = [];\n\n    // canvas\n    this.canvasHidden = null;\n    this.canvasHighlight = document.getElementById('result-highlight');\n    this.canvasGrid = document.getElementById('result-grid');\n    this.canvasResult = document.querySelector('#result');\n    this.canvasCropper = document.getElementById('cropper-canvas');\n  }\n\n  /**\n   * 初期化処理\n   */\n\n\n  _createClass(Cluster, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      var uploadArea = document.getElementById('upload-area');\n      uploadArea.addEventListener('change', function (e) {\n        _this.changeHandler(e);\n      });\n      uploadArea.addEventListener('dragenter', function (e) {\n        e.preventDefault();\n      });\n      uploadArea.addEventListener('dragover', function (e) {\n        e.preventDefault();\n      });\n      uploadArea.addEventListener('dragleave', function (e) {\n        e.preventDefault();\n      });\n      uploadArea.addEventListener('drop', function (e) {\n        e.preventDefault();\n        _this.changeHandler(e, e.dataTransfer.files[0]);\n      });\n\n      document.getElementById('run-btn').addEventListener('click', function (e) {\n        _this.run();\n      });\n\n      // グリッドの表示\n      this.drawGrid();\n    }\n\n    /**\n     * 画像アップロード時のcallback\n     */\n\n  }, {\n    key: \"changeHandler\",\n    value: function changeHandler(e, data) {\n      var _this2 = this;\n\n      // drag and dropの場合は e.dataTransfer.files[0] を使用\n      var file = data === undefined ? e.target.files[0] : data;\n\n      // 拡張子チェック\n      if (!file.type.match(/^image\\/(png|jpg|jpeg|gif)$/)) {\n        return;\n      }\n\n      // 容量チェック(5MB)\n      if (5 * 1024 * 1024 <= file.size) {\n        return;\n      }\n\n      var image = new Image();\n      var fileReader = new FileReader();\n\n      fileReader.onload = function (e) {\n        var base64 = e.target.result;\n\n        image.onload = function () {\n          _this2.canvasCropper.width = image.width;\n          _this2.canvasCropper.height = image.height;\n          var originalCtx = _this2.canvasCropper.getContext('2d');\n\n          // s:sourceImage, d:destinationCanvas\n          // ctx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)\n          originalCtx.drawImage(image, 0, 0, image.width, image.height, 0, 0, image.width, image.height);\n\n          // cropperの表示\n          _this2.showResult();\n\n          // cropperの設定\n          _this2.cropper = new _cropperjs2.default(_this2.canvasCropper, {\n            aspectRatio: 1,\n            preview: '.cropper-preview__img',\n            crop: function crop(e) {\n              _this2.canvasHidden = document.createElement('canvas');\n              var ctx = _this2.canvasHidden.getContext('2d');\n              ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);\n              ctx.drawImage(_this2.canvasCropper, e.detail.x, e.detail.y, e.detail.width, e.detail.height, 0, 0, CANVAS_SIZE, CANVAS_SIZE);\n            }\n          });\n        };\n        image.src = base64;\n      };\n\n      fileReader.readAsDataURL(file);\n    }\n\n    /**\n     * 画像のクラスタリングを実行\n     */\n\n  }, {\n    key: \"run\",\n    value: function run() {\n      var _this3 = this;\n\n      // 前のハイライトをクリア\n      this.clearHighlight();\n\n      var ctx = this.canvasHidden.getContext('2d');\n      var data = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE).data;\n      var len = CANVAS_SIZE * CANVAS_SIZE;\n      var w = [];\n      for (var i = 0; i < len; i++) {\n        w[i] = [data[i * 4], data[i * 4 + 1], data[i * 4 + 2], data[i * 4 + 3]];\n      }\n\n      _nodeKmeans2.default.clusterize(w, { k: K_NUM }, function (err, res) {\n        if (err) {\n          console.error(err);\n        } else {\n          // クラスタの多い順にソート\n          res.sort(function (a, b) {\n            return b.cluster.length - a.cluster.length;\n          });\n\n          // カラーコードを取得\n          for (var k = 0; k < K_NUM; k++) {\n            _this3.colorList[k] = res[k].centroid;\n          }\n\n          var resultCtx = _this3.canvasResult.getContext('2d');\n          resultCtx.clearRect(0, 0, 320, 320);\n          resultCtx.beginPath();\n\n          var _len = CANVAS_SIZE * CANVAS_SIZE;\n          for (var _i = 0; _i < _len; _i++) {\n            var color = void 0;\n            for (var _k = 0; _k < K_NUM; _k++) {\n              if (res[_k].cluster.includes(w[_i])) {\n                color = res[_k].centroid;\n                _this3.highlightList[_i] = _k;\n                break;\n              }\n            }\n            resultCtx.fillStyle = \"rgba(\" + color[0] + \", \" + color[1] + \", \" + color[2] + \", \" + color[3] + \")\";\n            resultCtx.fillRect(_i % CANVAS_SIZE * GRID_SIZE, Math.floor(_i / CANVAS_SIZE) * GRID_SIZE, GRID_SIZE, GRID_SIZE);\n          }\n\n          // カラーリストの表示\n          _this3.showColors(res);\n        }\n      });\n    }\n\n    /**\n     * カラーリストの表示\n     */\n\n  }, {\n    key: \"showColors\",\n    value: function showColors() {\n      var _this4 = this;\n\n      // カラーリストの削除\n      var list = document.querySelector('.colors-list');\n      var list_child = document.querySelectorAll('.colors-list li');\n      if (list_child.length) {\n        for (var i = 0; i < list_child.length; i++) {\n          list.removeChild(list_child[i]);\n        }\n      }\n\n      // カラーリストの追加処理\n      var fragment = document.createDocumentFragment();\n      for (var _i2 = 0, len = this.colorList.length; _i2 < len; _i2++) {\n        var li = document.createElement('li');\n        li.style.backgroundColor = \"rgba(\" + this.colorList[_i2][0] + \", \" + this.colorList[_i2][1] + \", \" + this.colorList[_i2][2] + \", \" + this.colorList[_i2][3] + \")\";\n        fragment.appendChild(li); // fragmentの追加する\n      }\n      list.appendChild(fragment);\n\n      // イベント設定\n      var colors = document.querySelectorAll('.colors-list li');\n\n      var _loop = function _loop(_i3) {\n        colors[_i3].addEventListener('click', function () {\n          _this4.highlightColor(_i3);\n        });\n      };\n\n      for (var _i3 = 0; _i3 < colors.length; _i3++) {\n        _loop(_i3);\n      }\n    }\n\n    /**\n     * グリッドの描画\n     */\n\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid() {\n      var ctx = this.canvasGrid.getContext('2d');\n      ctx.strokeStyle = 'rgba(255, 255, 255, 1)';\n\n      var size = CANVAS_DISP_SIZE;\n      for (var i = 0; i <= size; i += GRID_SIZE) {\n        if (i != 0 && i != size) {\n          // 縦\n          ctx.beginPath();\n          ctx.moveTo(i, 0);\n          ctx.lineTo(i, size);\n          // 横\n          ctx.moveTo(0, i);\n          ctx.lineTo(size, i);\n          ctx.stroke();\n        }\n      }\n    }\n\n    /**\n     * ハイライトのクリア\n     */\n\n  }, {\n    key: \"clearHighlight\",\n    value: function clearHighlight() {\n      var ctx = this.canvasHighlight.getContext('2d');\n      ctx.clearRect(0, 0, CANVAS_DISP_SIZE, CANVAS_DISP_SIZE);\n    }\n\n    /**\n     * 選択色のハイライト\n     */\n\n  }, {\n    key: \"highlightColor\",\n    value: function highlightColor(colorIndex) {\n      // アクティブ表示\n      var colors = document.querySelectorAll('.colors-list li');\n      for (var i = 0; i < colors.length; i++) {\n        if (i == colorIndex) {\n          colors[i].classList.add('active');\n        } else {\n          colors[i].classList.remove('active');\n        }\n      }\n\n      // カラーコードの表示\n      this.updateColorCode(this.colorList[colorIndex]);\n\n      // canvasの選択色のハイライト\n      var ctx = this.canvasHighlight.getContext('2d');\n      ctx.clearRect(0, 0, CANVAS_DISP_SIZE, CANVAS_DISP_SIZE);\n      ctx.beginPath();\n      ctx.fillStyle = \"rgba(0, 0, 0, .7)\";\n      ctx.strokeStyle = 'rgba(255, 255, 255, 1)';\n\n      var len = CANVAS_SIZE * CANVAS_SIZE;\n      for (var _i4 = 0; _i4 < len; _i4++) {\n        if (this.highlightList[_i4] != colorIndex) {\n          ctx.fillRect(_i4 % CANVAS_SIZE * GRID_SIZE, Math.floor(_i4 / CANVAS_SIZE) * GRID_SIZE, GRID_SIZE, GRID_SIZE);\n        } else {\n          ctx.rect(_i4 % CANVAS_SIZE * GRID_SIZE, Math.floor(_i4 / CANVAS_SIZE) * GRID_SIZE, GRID_SIZE, GRID_SIZE);\n          ctx.stroke();\n        }\n      }\n    }\n\n    /**\n     * カラーコードの更新\n     */\n\n  }, {\n    key: \"updateColorCode\",\n    value: function updateColorCode(color) {\n      document.getElementById('red-cc-bar').style.width = color[0] / 255 * 100 + \"%\";\n      document.getElementById('red-cc-number').innerHTML = Math.round(color[0] / DIVISOR) + \" (\" + color[0] + \")\";\n      document.getElementById('green-cc-bar').style.width = color[1] / 255 * 100 + \"%\";\n      document.getElementById('green-cc-number').innerHTML = Math.round(color[1] / DIVISOR) + \" (\" + color[1] + \")\";\n      document.getElementById('blue-cc-bar').style.width = color[2] / 255 * 100 + \"%\";\n      document.getElementById('blue-cc-number').innerHTML = Math.round(color[2] / DIVISOR) + \" (\" + color[2] + \")\";\n    }\n\n    /**\n     * 減色部分の表示\n     */\n\n  }, {\n    key: \"showResult\",\n    value: function showResult() {\n      document.getElementById('upload-area').classList.add('hide');\n      document.getElementById('uploaded-area').classList.add('show');\n\n      // document.querySelector('.cropper-area').classList.add('show');\n      // document.querySelector('.run-btn-area').classList.add('show');\n      // document.querySelector('.result-area').classList.add('show');\n      // document.querySelector('.colors').classList.add('show');\n      // document.querySelector('.color-code').classList.add('show');\n    }\n  }]);\n\n  return Cluster;\n}();\n\nexports.default = Cluster;"},"hash":"6c1c3208ad6d359aa07a147eae6f90da"}