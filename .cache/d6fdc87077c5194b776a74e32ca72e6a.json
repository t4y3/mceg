{"dependencies":[{"name":"cropperjs"},{"name":"./MedianCut"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _cropperjs = require(\"cropperjs\");\n\nvar _cropperjs2 = _interopRequireDefault(_cropperjs);\n\nvar _MedianCut = require(\"./MedianCut\");\n\nvar _MedianCut2 = _interopRequireDefault(_MedianCut);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// canvasサイズ\nvar CANVAS_SIZE = 32;\n// 表示時のグリッドのサイズ\nvar GRID_SIZE = 10;\n// 表示用canvasサイズ\nvar CANVAS_DISP_SIZE = CANVAS_SIZE * GRID_SIZE;\n// 減色時の色数\nvar K_NUM = 16;\n// MGOでのカラーパレット用の除数\nvar DIVISOR = 8.21;\n\nvar Cluster = function () {\n  function Cluster() {\n    _classCallCheck(this, Cluster);\n\n    this.cropper = null;\n\n    // カラーコードのリスト\n    this.highlightList = [];\n    this.colorList = [];\n\n    // canvas\n    this.canvasHidden = null;\n    this.canvasHighlight = document.getElementById('result-highlight');\n    this.canvasGrid = document.getElementById('result-grid');\n    this.canvasResult = document.querySelector('#result');\n    this.canvasCropper = document.getElementById('cropper-canvas');\n  }\n\n  /**\n   * 初期化処理\n   */\n\n\n  _createClass(Cluster, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      var uploadArea = document.getElementById('upload-area');\n      uploadArea.addEventListener('change', function (e) {\n        _this.changeHandler(e);\n      });\n      uploadArea.addEventListener('dragenter', function (e) {\n        e.preventDefault();\n      });\n      uploadArea.addEventListener('dragover', function (e) {\n        e.preventDefault();\n      });\n      uploadArea.addEventListener('dragleave', function (e) {\n        e.preventDefault();\n      });\n      uploadArea.addEventListener('drop', function (e) {\n        e.preventDefault();\n        _this.changeHandler(e, e.dataTransfer.files[0]);\n      });\n\n      document.getElementById('run-btn').addEventListener('click', function (e) {\n        _this.run();\n      });\n\n      // グリッドの表示\n      this.drawGrid();\n    }\n\n    /**\n     * 画像アップロード時のcallback\n     */\n\n  }, {\n    key: \"changeHandler\",\n    value: function changeHandler(e, data) {\n      var _this2 = this;\n\n      // drag and dropの場合は e.dataTransfer.files[0] を使用\n      var file = data === undefined ? e.target.files[0] : data;\n\n      // 拡張子チェック\n      if (!file.type.match(/^image\\/(png|jpg|jpeg|gif)$/)) {\n        return;\n      }\n\n      // 容量チェック(5MB)\n      if (5 * 1024 * 1024 <= file.size) {\n        return;\n      }\n\n      var image = new Image();\n      var fileReader = new FileReader();\n\n      fileReader.onload = function (e) {\n        var base64 = e.target.result;\n\n        image.onload = function () {\n          _this2.canvasCropper.width = image.width;\n          _this2.canvasCropper.height = image.height;\n          var originalCtx = _this2.canvasCropper.getContext('2d');\n\n          // s:sourceImage, d:destinationCanvas\n          // ctx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)\n          originalCtx.drawImage(image, 0, 0, image.width, image.height, 0, 0, image.width, image.height);\n\n          // cropperの表示\n          _this2.showResult();\n\n          // cropperの設定\n          _this2.cropper = new _cropperjs2.default(_this2.canvasCropper, {\n            aspectRatio: 1,\n            preview: '.cropper-preview__img',\n            crop: function crop(e) {\n              _this2.canvasHidden = document.createElement('canvas');\n              var ctx = _this2.canvasHidden.getContext('2d');\n              ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);\n              ctx.drawImage(_this2.canvasCropper, e.detail.x, e.detail.y, e.detail.width, e.detail.height, 0, 0, CANVAS_SIZE, CANVAS_SIZE);\n            }\n          });\n        };\n        image.src = base64;\n      };\n\n      fileReader.readAsDataURL(file);\n    }\n\n    /**\n     * 画像のクラスタリングを実行\n     */\n\n  }, {\n    key: \"run\",\n    value: function run() {\n      // 前のハイライトをクリア\n      this.clearHighlight();\n\n      var ctx = this.canvasHidden.getContext('2d');\n      var data = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE).data;\n      var len = CANVAS_SIZE * CANVAS_SIZE;\n      var w = [];\n      for (var i = 0; i < len; i++) {\n        w[i] = [data[i * 4], data[i * 4 + 1], data[i * 4 + 2], data[i * 4 + 3]];\n      }\n\n      var imagedata = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);\n      // Obtain color information of image (画像のカラー情報の取得)\n      var colors = this.getColorInfo(imagedata);\n\n      // reduced color (減色)\n      var medianCut = new _MedianCut2.default(imagedata, colors);\n      medianCut.run(16, true);\n\n      var resultCtx = this.canvasResult.getContext('2d');\n      resultCtx.clearRect(0, 0, 320, 320);\n      resultCtx.beginPath();\n\n      // カラーリストの取得\n      this.colorList = medianCut.rep_color;\n\n      for (var _i = 0; _i < len; _i++) {\n        resultCtx.fillStyle = \"rgba(\" + imagedata.data[_i * 4] + \", \" + imagedata.data[_i * 4 + 1] + \", \" + imagedata.data[_i * 4 + 2] + \", \" + imagedata.data[_i * 4 + 3] + \")\";\n        resultCtx.fillRect(_i % CANVAS_SIZE * GRID_SIZE, Math.floor(_i / CANVAS_SIZE) * GRID_SIZE, GRID_SIZE, GRID_SIZE);\n\n        for (var j = 0, jLen = this.colorList.length; j < jLen; j++) {\n          if (imagedata.data[_i * 4] == this.colorList[j]['r'] && imagedata.data[_i * 4 + 1] == this.colorList[j]['g'] && imagedata.data[_i * 4 + 2] == this.colorList[j]['b']) {\n            this.highlightList[_i] = j;\n          }\n        }\n      }\n\n      this.showColors();\n    }\n\n    /**\n     * カラーリストの表示\n     */\n\n  }, {\n    key: \"showColors\",\n    value: function showColors() {\n      var _this3 = this;\n\n      // カラーリストの削除\n      var list = document.querySelector('.colors-list');\n      var list_child = document.querySelectorAll('.colors-list li');\n      if (list_child.length) {\n        for (var i = 0; i < list_child.length; i++) {\n          list.removeChild(list_child[i]);\n        }\n      }\n\n      // カラーリストの追加処理\n      var fragment = document.createDocumentFragment();\n      for (var _i2 = 0, len = this.colorList.length; _i2 < len; _i2++) {\n        var li = document.createElement('li');\n        li.style.backgroundColor = \"rgba(\" + this.colorList[_i2]['r'] + \", \" + this.colorList[_i2]['g'] + \", \" + this.colorList[_i2]['b'] + \", 1)\";\n        fragment.appendChild(li); // fragmentの追加する\n      }\n      list.appendChild(fragment);\n\n      // イベント設定\n      var colors = document.querySelectorAll('.colors-list li');\n\n      var _loop = function _loop(_i3) {\n        colors[_i3].addEventListener('click', function () {\n          _this3.highlightColor(_i3);\n        });\n      };\n\n      for (var _i3 = 0; _i3 < colors.length; _i3++) {\n        _loop(_i3);\n      }\n    }\n\n    /**\n     * グリッドの描画\n     */\n\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid() {\n      var ctx = this.canvasGrid.getContext('2d');\n      ctx.strokeStyle = 'rgba(255, 255, 255, 1)';\n\n      var size = CANVAS_DISP_SIZE;\n      for (var i = 0; i <= size; i += GRID_SIZE) {\n        if (i != 0 && i != size) {\n          // 縦\n          ctx.beginPath();\n          ctx.moveTo(i, 0);\n          ctx.lineTo(i, size);\n          // 横\n          ctx.moveTo(0, i);\n          ctx.lineTo(size, i);\n          ctx.stroke();\n        }\n      }\n    }\n\n    /**\n     * ハイライトのクリア\n     */\n\n  }, {\n    key: \"clearHighlight\",\n    value: function clearHighlight() {\n      var ctx = this.canvasHighlight.getContext('2d');\n      ctx.clearRect(0, 0, CANVAS_DISP_SIZE, CANVAS_DISP_SIZE);\n    }\n\n    /**\n     * 選択色のハイライト\n     */\n\n  }, {\n    key: \"highlightColor\",\n    value: function highlightColor(colorIndex) {\n      // アクティブ表示\n      var colors = document.querySelectorAll('.colors-list li');\n      for (var i = 0; i < colors.length; i++) {\n        if (i == colorIndex) {\n          colors[i].classList.add('active');\n        } else {\n          colors[i].classList.remove('active');\n        }\n      }\n\n      // カラーコードの表示\n      this.updateColorCode(this.colorList[colorIndex]);\n\n      // canvasの選択色のハイライト\n      var ctx = this.canvasHighlight.getContext('2d');\n      ctx.clearRect(0, 0, CANVAS_DISP_SIZE, CANVAS_DISP_SIZE);\n      ctx.beginPath();\n      ctx.fillStyle = \"rgba(0, 0, 0, .7)\";\n      ctx.strokeStyle = 'rgba(255, 255, 255, 1)';\n\n      var len = CANVAS_SIZE * CANVAS_SIZE;\n      for (var _i4 = 0; _i4 < len; _i4++) {\n        if (this.highlightList[_i4] != colorIndex) {\n          ctx.fillRect(_i4 % CANVAS_SIZE * GRID_SIZE, Math.floor(_i4 / CANVAS_SIZE) * GRID_SIZE, GRID_SIZE, GRID_SIZE);\n        } else {\n          ctx.rect(_i4 % CANVAS_SIZE * GRID_SIZE, Math.floor(_i4 / CANVAS_SIZE) * GRID_SIZE, GRID_SIZE, GRID_SIZE);\n          ctx.stroke();\n        }\n      }\n    }\n\n    /**\n     * カラーコードの更新\n     */\n\n  }, {\n    key: \"updateColorCode\",\n    value: function updateColorCode(color) {\n      document.getElementById('red-cc-bar').style.width = color['r'] / 255 * 100 + \"%\";\n      document.getElementById('red-cc-number').innerHTML = Math.round(color['r'] / DIVISOR) + \" (\" + color['r'] + \")\";\n      document.getElementById('green-cc-bar').style.width = color['g'] / 255 * 100 + \"%\";\n      document.getElementById('green-cc-number').innerHTML = Math.round(color['g'] / DIVISOR) + \" (\" + color['g'] + \")\";\n      document.getElementById('blue-cc-bar').style.width = color['b'] / 255 * 100 + \"%\";\n      document.getElementById('blue-cc-number').innerHTML = Math.round(color['b'] / DIVISOR) + \" (\" + color['b'] + \")\";\n    }\n\n    /**\n     * 減色部分の表示\n     */\n\n  }, {\n    key: \"showResult\",\n    value: function showResult() {\n      document.getElementById('upload-area').classList.add('hide');\n      document.getElementById('uploaded-area').classList.add('show');\n    }\n\n    /**\n     * カラー情報の取得\n     */\n\n  }, {\n    key: \"getColorInfo\",\n    value: function getColorInfo(imagedata) {\n      var height = imagedata.height;\n      var width = imagedata.width;\n      var raw = imagedata.data;\n\n      // 使用色/使用回数(面積)を取得\n      var cnt = 0;\n      var uses_colors = new Object();\n\n      for (var i = 0; i < height; i++) {\n        for (var j = 0; j < width; j++) {\n          var key = raw[cnt] + ',' + raw[cnt + 1] + ',' + raw[cnt + 2];\n          if (!uses_colors[key]) uses_colors[key] = 1;else uses_colors[key] += 1;\n\n          cnt = cnt + 4;\n        }\n      }\n\n      // 連想配列を配列へ設定\n      var rgb = void 0;\n      var colors = new Array();\n      for (var _key in uses_colors) {\n        rgb = _key.split(\",\");\n        colors[colors.length] = {\n          'r': parseInt(rgb[0], 10),\n          'g': parseInt(rgb[1], 10),\n          'b': parseInt(rgb[2], 10),\n          'uses': uses_colors[_key]\n        }; // 使用数\n      }\n      return colors;\n    }\n  }]);\n\n  return Cluster;\n}();\n\nexports.default = Cluster;"},"hash":"b6b1ecd453cf484cd27e5507609698ca"}