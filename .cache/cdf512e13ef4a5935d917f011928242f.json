{"dependencies":[{"name":"underscore","loc":{"line":23,"column":18}},{"name":"process"}],"generated":{"js":"var process = require(\"process\");\n'use strict';\n\n/*\n * node-kmeans\n * Copyright(c) 2012 Philmod <philippe.modard@gmail.com>\n * MIT Licensed\n */\n\n/*\nAsynchronous implementation of the k-means clustering algorithm.\n\nThe kmeans function takes as input the number k of clusters and a list of N\ninput vectors and it outputs an object with two attributes:\n  - centroids: an Array of k vectors containing the centroid of each cluster\n  - assignments: An Array of size N representing for each input vector the\n    index of the cluster\n\nThe kmeans will return an error if:\n  - N < k\n  - The number of different input vectors is smaller than k\n*/\n\nconst _ = require('underscore');\n\n\n/**\n * Compute the Euclidean distance\n *\n * @param {Array} a\n * @param {Array} b\n * @api private\n */\n\nfunction distance(a, b) {\n  if (a.length !== b.length) {\n    return (new Error('The vectors must have the same length'));\n  }\n  let d = 0.0;\n  for (let i = 0, max = a.length; i < max; ++i) {\n    d += Math.pow((a[i] - b[i]), 2);\n  }\n  return Math.sqrt(d);\n}\n\nclass Group {\n  constructor() {\n    this.centroidMoved = true;\n  }\n\n  initCluster() {\n    this.cluster = []; // dimensions\n    this.clusterInd = []; // index\n  }\n\n  /**\n   * Define Centroid\n   *  - if they exist, calculate the new position\n   *  - otherwise, randomly choose one existing item\n   */\n  defineCentroid(self) {\n    this.centroidOld = (this.centroid) ? this.centroid : [];\n    if (this.centroid && this.cluster.length > 0) {\n      this.calculateCentroid();\n    } else { // random selection\n      const i = Math.floor(Math.random() * self.indexes.length);\n      this.centroidIndex = self.indexes[i];\n      self.indexes.splice(i, 1);\n      this.centroid = [];\n      if (!_.isArray(self.v[this.centroidIndex])) { // only one dimension\n        this.centroid[0] = self.v[this.centroidIndex];\n      } else {\n        for (let j = 0, max = self.v[this.centroidIndex].length; j < max; ++j) {\n          this.centroid[j] = self.v[this.centroidIndex][j];\n        }\n      }\n    }\n    this.centroidMoved = _.isEqual(this.centroid, this.centroidOld);\n    return this;\n  }\n\n  calculateCentroid() {\n    this.centroid = [];\n    for (let i = 0; i < this.cluster.length; ++i) { // loop through the cluster elements\n      for (let j = 0, max = this.cluster[i].length; j < max; ++j) { // loop through the dimensions\n        this.centroid[j] = this.centroid[j]\n          ? this.centroid[j] + this.cluster[i][j]\n          : this.cluster[i][j];\n      }\n    }\n    for (let i = 0, max = this.centroid.length; i < max; ++i) {\n      this.centroid[i] = this.centroid[i] / this.cluster.length; // average\n    }\n    return this;\n  }\n\n  distanceObjects(self) {\n    if (!this.distances) {\n      this.distances = [];\n    }\n    for (let i = 0, max = self.v.length; i < max; ++i) {\n      this.distances[i] = distance(this.centroid, self.v[i]);\n    }\n    return this;\n  }\n}\n\n\nclass Clusterize {\n  constructor(vector, options, callback) {\n    if (!callback || !options || !vector) {\n      throw new Error('Provide 3 arguments: vector, options, callback');\n    }\n    if (typeof callback !== 'function') {\n      throw new Error('Provide a callback function');\n    }\n    if (!options || !options.k || options.k < 1) {\n      return callback(new Error('Provide a correct number k of clusters'));\n    }\n    if (!_.isArray(vector)) {\n      return callback(new Error('Provide an array of data'));\n    }\n\n    this.options = options;\n    this.v = this.checkV(vector);\n    this.k = this.options.k;\n    if (this.v.length < this.k) {\n      const errMessage = `The number of points must be greater than\n      the number k of clusters`;\n      return callback(new Error(errMessage));\n    }\n\n    this.initialize(); // initialize the group arrays\n\n    const self = this;\n    let moved = -1;\n\n    function iterate() {\n      if (moved === 0) {\n        return callback(null, self.output()); // converged if 0 centroid has moved\n      }\n      moved = 0;\n      for (let i = 0, max = self.groups.length; i < max; ++i) {\n        self.groups[i].defineCentroid(self); // define the new centroids\n        self.groups[i].distanceObjects(self); // distances from centroids to items\n      }\n      self.clustering(); // clustering by choosing the centroid the closest of each item\n      for (let i = 0, max = self.groups.length; i < max; ++i) {\n        // check how many centroids have moved in this iteration\n        if (self.groups[i].centroidMoved) {\n          moved++;\n        }\n      }\n      return process.nextTick(iterate);\n    }\n    return iterate();\n  }\n\n  checkV(v) {\n    let dim = 1;\n    if (_.isArray(v[0])) {\n      dim = v[0].length;\n    }\n    for (let i = 0, max = v.length; i < max; ++i) {\n      if (!_.isArray(v[i])) {\n        if (dim !== 1) {\n          throw new Error('All the elements must have the same dimension');\n        }\n        v[i] = Number(v[i]);\n        if (isNaN(v[i])) {\n          throw new Error('All the elements must be float type');\n        }\n      } else {\n        if (v[i].length !== dim) {\n          throw new Error('All the elements must have the same dimension');\n        }\n        for (let j = 0, max2 = v[i].length; j < max2; ++j) {\n          v[i][j] = Number(v[i][j]);\n          if (isNaN(v[i][j])) {\n            throw new Error('All the elements must be float type');\n          }\n        }\n      }\n    }\n    return v;\n  }\n\n  initialize() {\n    this.groups = [];\n    for (let i = 0, max = this.k; i < max; ++i) {\n      this.groups[i] = new Group(this);\n    }\n    this.indexes = []; // used to choose randomly the initial centroids\n    for (let i = 0, max = this.v.length; i < max; ++i) {\n      this.indexes[i] = i;\n    }\n    return this;\n  }\n\n  clustering() {\n    for (let j = 0, max = this.groups.length; j < max; ++j) {\n      this.groups[j].initCluster();\n    }\n    for (let i = 0, max = this.v.length; i < max; ++i) {\n      let min = this.groups[0].distances[i];\n      let indexGroup = 0;\n      for (let j = 1, max2 = this.groups.length; j < max2; ++j) {\n        if (this.groups[j].distances[i] < min) {\n          min = this.groups[j].distances[i];\n          indexGroup = j;\n        }\n      }\n      this.groups[indexGroup].cluster.push(this.v[i]);\n      this.groups[indexGroup].clusterInd.push(i);\n    }\n    return this;\n  }\n\n  output() {\n    const out = [];\n    for (let j = 0, max = this.groups.length; j < max; ++j) {\n      out[j] = _.pick(this.groups[j], 'centroid', 'cluster', 'clusterInd');\n    }\n    return out;\n  }\n}\n\nexports.clusterize = (vector, options, callback) => {\n  return new Clusterize(vector, options, callback);\n};\n\nexports._class = Clusterize;\n"},"hash":"25c79389d15e2e5b5d61a12db65128a0"}